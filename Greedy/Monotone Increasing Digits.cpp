/*738. 单调递增的数字
给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。
（当且仅当每个相邻位数上的数字 x 和 y 满足 x <= y 时，我们称这个整数是单调递增的。）
示例 1:
输入: N = 10
输出: 9
示例 2:

输入: N = 1234
输出: 1234
示例 3:

输入: N = 332
输出: 299
说明: N 是在 [0, 10^9] 范围内的一个整数。
*/

/*
这里刚开始直接对N处理 由于需要处理N的每一位数字 所以不方便
转换为字符串后更加便于操作
由于需要的是一个单调递增的数字 因此从最高位开始遍历每一位数 每次都和其后一位比较
如果当前位大于后一位 这时需要进行对字符串做如下处理
对于当前位之前的所有数位 从后到前遍历 寻找尽量靠后的数位上的数字减一  确保处理后的数字尽可能大
尽管已经遍历过的是单调递增序列 但如果选取处理的数位与前一位相等 该数位减一后会小于前一位 破坏了单调递增性
因此便需要改数位尽量靠后且该数位前一位的数字不与该数位上的数字相等 这样修改该位后便不会影响单调递增性（该数位之前的数字必然单调递增）
修改该位后 为了使得该位尽量大 应该再将该位后的所有数位（如果存在）置为9 
*/
class Solution {
public:
    int monotoneIncreasingDigits(int N) 
    {
        string ret = to_string(N);                               //数字转化为字符串方便对其每一位处理
        int len = ret.size();
        for(int i = 0; i < len - 1; i++)
        {
            int index = i;                                       //记录处理数位
            if(ret[i] > ret[i + 1])
            {
                while(ret[index] == ret[index - 1] && index > 0) //找到合适的处理数位
                {
                    index--;
                }
                ret[index]--;
                for(index++; index < len; index++)               //对处理数位后的所有数位（如果存在）置为9
                {
                    ret[index] = '9';
                }
                break;
            }
        }
        return stoi(ret);
    }
};