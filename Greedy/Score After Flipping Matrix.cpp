/*861.翻转矩阵后的得分

有一个二维矩阵 A 其中每个元素的值为 0 或 1 。
移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。
在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。
返回尽可能高的分数。

示例：
输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]
输出：39
解释：
转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]
0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39
 

提示：
1.1 <= A.length <= 20
2.1 <= A[0].length <= 20
3.A[i][j] 是 0 或 1
*/

/*
先让每一行都让1开头 如果以0开头则翻转 对每一个元素，使其与1异或 这样 可以使0变为1 1变为0
然后对于每一列元素 如果0的个数不少于1的个数 也进行翻转 这里比较0 和 1的个数可以只记录0的个数 然后构造 temp为行数len / 2 + len % 2 在0的个数不少于temp时翻转
*/

class Solution {
public:
    int matrixScore(vector<vector<int>>& A) 
    {
        int i,j;
        int len = A.size();                 //行数
        int len_ = A[0].size();             //列数
        int temp = len / 2 + len % 2;       //用于判断0与1的个数孰多孰少
        
        for(i = 0; i < len; i++)            //将每一行都以0开头
        {
            if (!A[i][0])
            {
                for(j = 0; j < len_; j++)
                {
                    A[i][j] ^= 1;
                }
            }
        }
        for(j = 0; j < len_; j++)           //将每一列1的个数大于0的个数
        {
            int cnt = 0, cnt_ = 0;
            for(i = 0; i < len; i++)
            {
                if(!A[i][j])
                {
                    cnt++;
                }
            }
            if(cnt >= temp)
            {
                for(int k = 0; k < len; k++)
                {
                    A[k][j] ^= 1;
                }
            }
        }
        int sum = 0;            
        for(i = 0; i < len; i++)            //计算二进制数的和转化为十进制
        {
            for(j = 0; j < len_; j++)
            {
                sum += A[i][j] * pow(2, (len_ -  j -1)); 
            }
        }
        return sum;
    }
};