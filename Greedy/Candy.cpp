/*135.分发糖果
老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。
你需要按照以下要求，帮助老师给这些孩子分发糖果：
每个孩子至少分配到 1 个糖果。
相邻的孩子中，评分高的孩子必须获得更多的糖果。
那么这样下来，老师至少需要准备多少颗糖果呢？

示例 1:
输入: [1,0,2]
输出: 5
解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。

示例 2:
输入: [1,2,2]
输出: 4
解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。
第三个孩子只得到 1 颗糖果，这已满足上述两个条件。
*/
/*
构造一个结果数组 每一个元素对应着第i个孩子应分到的糖果
给定的数组构成一个序列，要么是单调递增的 要么是单调递减的，要么是平稳的(即序列中的每一个值都相同)
先找到一个单调递增或者递减序列的起始位置与结束位置
如果是单调递增从起始位置的后一位置到结束位置将对应的结果数组中的每一个每一个初始值依次加上其相对于起始位置的偏移量
如果该序列后是一个递减序列，那么从该递增序列的结束位置开始，找到这个递减序列的起始位置 (即单调递增序列的结束位置) 与结束位置 
从结束位置的前一个位置开始到起始位置,对应的每一个结果数组中的元素的初始值加上其相对于结束位置的偏移量
但是这里单调递增序列的结束位置作为了单调递减序列的起始位置 因此它是这两个序列的极大值 在单调递减更新对于的结果数组的元素时应该为两个序列更新值的最大值
如果先递减 再递增那么临界点的位置是两个序列的极小值 不需要进一步考虑 对于的结果数组的元素必定为1
如果遇到了一个平稳序列 只需要继续向后遍历即可
*/
class Solution 
{
    public:
        int candy(vector<int>& ratings) 
        {
            int len = ratings.size();
            int start = -1, end = -1;                                //单调序列的起始位置与结束位置
            if(len == 1 || !len)return len;
            vector<int>res(len, 1);                                  //结果数组
            int candys = 0;                                          //准备的糖果总量是各个结果数组的元素之和
            int i,j;
            for(i = 0; i < len -1;)
            {
                if(ratings[i +1] > ratings[i])                       //单调递增序列
                {1
                    start = i;
                    while(i < len -1 && ratings[i+1] > ratings[i])   //找到单调递增序列的结束位置
                    {
                        i++;
                    }
                    end = i;
                    for(j = start +1; j <= end; j++)                 //更新结果数组
                    {
                        res[j] = j - start + 1;
                    }
                }
                else if(ratings[i + 1] < ratings[i])                 //单调递减序列
                {
                    start = i;
                    while(i < len -1 && ratings[i +1] < ratings[i])
                    {
                        i++;
                    }
                    end = i;
                for(j = end - 1; j >= start; j--)
                    {
                        res[j] =  max(1 + end - j, res[j]);          //考虑到前一个序列为单调递增序列 那么此时序列的起始位置的值是两个序列的最大值 因此对应的结果数组的值应该为两次更新的最大值
                    }
                }
                else
                { 
                    i++;
                }

            }
            for(auto item:res)
            {
                candys += item;
            }
            return candys;
        }
};